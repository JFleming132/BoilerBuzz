import SwiftUIimport GoogleMapsimport GooglePlaces// Updated model for API response structurestruct UserEventsResponse: Codable {    let success: Bool    let data: UserEventsData}struct UserEventsData: Codable {    let events: [EventData]    let friends: [String]}// Updated EventData modelstruct EventData: Codable {    let _id: String    let title: String    let description: String    let location: String    let date: Double    let authorUsername: String    let authorUserId: String // New field from updated API}// Updated EventPin to include friend statusstruct EventPin {    let id: String    let title: String    let description: String    let location: String    let date: Date    let authorUsername: String    let authorUserId: String // New field    let latitude: Double    let longitude: Double    let isFriendEvent: Bool // New field to track if created by a friend}// Response model for Geocoding APIstruct GeocodeResponse: Codable {    let results: [GeocodeResult]    let status: String}struct GeocodeResult: Codable {    let geometry: GeocodeGeometry}struct GeocodeGeometry: Codable {    let location: GeocodeLocation}struct GeocodeLocation: Codable {    let lat: Double    let lng: Double}// Location model for barsstruct BarLocation {    let name: String    let description: String    let latitude: Double    let longitude: Double}// Response model for Distance Matrix APIstruct DistanceMatrixResponse: Codable {    struct Row: Codable {        struct Element: Codable {            struct Distance: Codable {                let text: String                let value: Int            }                        let distance: Distance            let status: String        }                let elements: [Element]    }        let rows: [Row]}class EventManager: ObservableObject {        @Published var events: [EventPin] = []        @Published var isLoading = true        @Published var friendIds: [String] = [] // Store friend IDs        var errorMessage: String?        private let baseURL = "http://54.146.194.154:3000/api/pin"        private let googleMapsAPIKey = "AIzaSyD9fysUB7FOQTQILo0TEdTOo59cL-4weVM"        // Calculate distance between two coordinates    func fetchDistance(        from origin: CLLocationCoordinate2D,        to destination: CLLocationCoordinate2D,        completion: @escaping (String?) -> Void    ) {        let baseURL = "https://maps.googleapis.com/maps/api/distancematrix/json"        let originParam = "\(origin.latitude),\(origin.longitude)"        let destinationParam = "\(destination.latitude),\(destination.longitude)"        let urlString = "\(baseURL)?origins=\(originParam)&destinations=\(destinationParam)&key=\(googleMapsAPIKey)"                guard let url = URL(string: urlString) else {            print("Invalid Distance Matrix URL")            completion(nil)            return        }                URLSession.shared.dataTask(with: url) { data, response, error in            if let error = error {                print("Distance Matrix API error: \(error.localizedDescription)")                completion(nil)                return            }                        guard let data = data else {                print("No data received from Distance Matrix API")                completion(nil)                return            }                        do {                let response = try JSONDecoder().decode(DistanceMatrixResponse.self, from: data)                if let element = response.rows.first?.elements.first,                   element.status == "OK" {                    completion(element.distance.text)                } else {                    print("Failed to fetch distance")                    completion(nil)                }            } catch {                print("Error decoding Distance Matrix response: \(error)")                completion(nil)            }        }.resume()    }        func fetchUserEvents(completion: @escaping () -> Void) {            self.isLoading = true                        guard let userId = UserDefaults.standard.string(forKey: "userId") else {                print("User ID not found. Please log in again.")                errorMessage = "User ID not found. Please log in again."                self.isLoading = false                completion()                return            }                        print("Fetching RSVP events for user: \(userId)")            let urlString = "\(baseURL)/user-events/\(userId)"                        guard let url = URL(string: urlString) else {                errorMessage = "Invalid URL"                self.isLoading = false                completion()                return            }                        URLSession.shared.dataTask(with: url) { [weak self] data, response, error in                guard let self = self else { return }                                if let error = error {                    print("Network error: \(error.localizedDescription)")                    self.errorMessage = "Network error: \(error.localizedDescription)"                    DispatchQueue.main.async {                        self.isLoading = false                        completion()                    }                    return                }                                guard let data = data else {                    self.errorMessage = "No data received"                    DispatchQueue.main.async {                        self.isLoading = false                        completion()                    }                    return                }                                do {                    // Updated to use the new response structure                    let response = try JSONDecoder().decode(UserEventsResponse.self, from: data)                    let eventsData = response.data.events                    let friendIds = response.data.friends                                        print("Received \(eventsData.count) events and \(friendIds.count) friends from API")                                        // Store friend IDs for later use                    DispatchQueue.main.async {                        self.friendIds = friendIds                        self.events.removeAll()                    }                                        // Track geocoding completion                    let geocodingGroup = DispatchGroup()                                        // Process each event                    for event in eventsData {                        print("Event ID: \(event._id)")                        print("Title: \(event.title)")                        print("Description: \(event.description)")                        print("Location: \(event.location)")                        print("Date: \(Date(timeIntervalSince1970: event.date/1000))")                        print("Author: \(event.authorUsername)")                        print("Author ID: \(event.authorUserId)")                        print("-------------------------------------------------")                                                geocodingGroup.enter()                                                // Geocode event location and add it as a pin                        self.geocodeAddress(event.location) { coordinate in                            defer {                                geocodingGroup.leave()                            }                                                        if let coordinate = coordinate {                                // Check if this event is created by a friend                                let isFriendEvent = friendIds.contains(event.authorUserId)                                                                // Create pin with coordinates and friend status                                let eventPin = EventPin(                                    id: event._id,                                    title: event.title,                                    description: event.description,                                    location: event.location,                                    date: Date(timeIntervalSince1970: event.date/1000),                                    authorUsername: event.authorUsername,                                    authorUserId: event.authorUserId,                                    latitude: coordinate.latitude,                                    longitude: coordinate.longitude,                                    isFriendEvent: isFriendEvent                                )                                                                // Add to events array on main thread                                DispatchQueue.main.async {                                    self.events.append(eventPin)                                    print("Added pin for event: \(event.title) at \(coordinate.latitude), \(coordinate.longitude), Friend event: \(isFriendEvent)")                                }                            } else {                                print("Failed to geocode event location: \(event.location)")                            }                        }                    }                                        // When all geocoding is complete                    geocodingGroup.notify(queue: .main) {                        print("All geocoding completed. Total events with coordinates: \(self.events.count)")                        self.isLoading = false                        self.objectWillChange.send()                        completion()                    }                                    } catch {                    print("Error decoding events: \(error)")                    print("Raw response data: \(String(data: data, encoding: .utf8) ?? "Unable to convert to string")")                    self.errorMessage = "Error decoding events: \(error.localizedDescription)"                    DispatchQueue.main.async {                        self.isLoading = false                        completion()                    }                }            }.resume()        }    // Convert address to coordinates using Google Geocoding API    func geocodeAddress(_ address: String, completion: @escaping (CLLocationCoordinate2D?) -> Void) {        // Append city and state to the address        let fullAddress = "\(address), West Lafayette, IN"        print("Geocoding address: \(fullAddress)")                // Encode the full address to be safe for a URL        let geocodeURLString = "https://maps.googleapis.com/maps/api/geocode/json?address=\(fullAddress.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")&key=\(googleMapsAPIKey)"        print("Geocode URL: \(geocodeURLString)")                guard let geocodeURL = URL(string: geocodeURLString) else {            print("Invalid geocode URL")            completion(nil)            return        }                URLSession.shared.dataTask(with: geocodeURL) { data, response, error in            // Print HTTP status for debugging            if let httpResponse = response as? HTTPURLResponse {                print("Geocoding HTTP status: \(httpResponse.statusCode)")            }                        if let error = error {                print("Geocoding error: \(error.localizedDescription)")                completion(nil)                return            }                        guard let data = data else {                print("No data received from geocoding API")                completion(nil)                return            }                        do {                let geocodeResponse = try JSONDecoder().decode(GeocodeResponse.self, from: data)                print("Geocoding status: \(geocodeResponse.status)")                print("Received \(geocodeResponse.results.count) geocoding results")                                if let firstResult = geocodeResponse.results.first {                    let latitude = firstResult.geometry.location.lat                    let longitude = firstResult.geometry.location.lng                    print("First result: \(latitude), \(longitude)")                    completion(CLLocationCoordinate2D(latitude: latitude, longitude: longitude))                } else {                    print("No results found for address: \(address)")                    completion(nil)                }            } catch {                print("Error decoding geocoding response: \(error)")                // Print raw response for debugging                if let jsonString = String(data: data, encoding: .utf8) {                    print("Raw geocoding response: \(jsonString)")                }                completion(nil)            }        }.resume()    }}struct GoogleMapViewRepresentable: UIViewRepresentable {    var location: CLLocationCoordinate2D?    @ObservedObject var eventManager: EventManager        // Hard-coded bar locations    private let barLocations: [BarLocation] = [        BarLocation(name: "Harry's Chocolate Shop", description: "Popular campus bar", latitude: 40.42378, longitude: -86.90908),        BarLocation(name: "Brothers Bar & Grill", description: "Sports bar with food", latitude: 40.42415, longitude: -86.90838),        BarLocation(name: "The Tap", description: "Craft beer bar", latitude: 40.42305, longitude: -86.90683),        BarLocation(name: "Where Else", description: "Youthful bar", latitude: 40.42407, longitude: -86.90854),        BarLocation(name: "9 Irish Brothers", description: "Cozy vibe and great Guinness", latitude: 40.42306, longitude: -86.90321),        BarLocation(name: "Neon Cactus", description: "Giant club on campus", latitude: 40.42329, longitude: -86.90065)    ]        func makeUIView(context: Context) -> GMSMapView {        let options = GMSMapViewOptions()        // Center on West Lafayette with appropriate zoom        options.camera = GMSCameraPosition.camera(withLatitude: 40.4240, longitude: -86.9080, zoom: 15)        let mapView = GMSMapView(options: options)        mapView.isMyLocationEnabled = true        mapView.settings.myLocationButton = true                // Set the delegate to receive location updates        mapView.delegate = context.coordinator                return mapView    }        func updateUIView(_ uiView: GMSMapView, context: Context) {        print("updateUIView called, isLoading: \(eventManager.isLoading), events count: \(eventManager.events.count)")        if !eventManager.isLoading {            // Clear existing markers and our tracking collection            uiView.clear()            context.coordinator.clearAllMarkers()                        // Re-add all markers            addBarMarkers(to: uiView, coordinator: context.coordinator)            addEventMarkers(to: uiView, coordinator: context.coordinator)                        if let location = location {                // Animate camera to user location                let camera = GMSCameraPosition.camera(withLatitude: location.latitude, longitude: location.longitude, zoom: 15)                uiView.animate(to: camera)            } else if let firstEvent = eventManager.events.first {                // If no specific location but we have events, center on first event                let camera = GMSCameraPosition.camera(withLatitude: firstEvent.latitude, longitude: firstEvent.longitude, zoom: 15)                uiView.animate(to: camera)            }                        // If user location is available, update all distances immediately            if let userLocation = uiView.myLocation?.coordinate {                context.coordinator.updateAllMarkerDistances(with: userLocation)            }        }    }        // Create a coordinator to handle delegate callbacks    func makeCoordinator() -> Coordinator {        Coordinator(self)    }            class Coordinator: NSObject, GMSMapViewDelegate {        var parent: GoogleMapViewRepresentable        private var lastUserLocation: CLLocationCoordinate2D?        private var currentlyOpenInfoWindow: GMSMarker?                // Track all markers manually since GMSMapView doesn't provide access to them        private var eventMarkers: [GMSMarker] = []                init(_ parent: GoogleMapViewRepresentable) {            self.parent = parent        }                // Add a marker to our tracking collection        func trackMarker(_ marker: GMSMarker, isEvent: Bool = false) {            if isEvent {                eventMarkers.append(marker)            }        }                // Clear our marker tracking collections        func clearAllMarkers() {            eventMarkers.removeAll()            currentlyOpenInfoWindow = nil        }                // Called when my location button is tapped        func didTapMyLocationButton(for mapView: GMSMapView) -> Bool {            // Update distances when user explicitly goes to their location            if let userLocation = mapView.myLocation?.coordinate {                lastUserLocation = userLocation                updateAllMarkerDistances(with: userLocation)            }            return false // Allow default behavior        }                // Called when user's location changes        func mapView(_ mapView: GMSMapView, didChange position: GMSCameraPosition) {            // Check if user location is available and different from last known location            if let userLocation = mapView.myLocation?.coordinate {                // If location hasn't changed significantly, don't update                if let lastLocation = lastUserLocation,                   abs(lastLocation.latitude - userLocation.latitude) < 0.0001 &&                   abs(lastLocation.longitude - userLocation.longitude) < 0.0001 {                    return                }                                // Store new location                lastUserLocation = userLocation                                // Update distances for all event markers                updateAllMarkerDistances(with: userLocation)            }        }                // Called when user taps on marker        func mapView(_ mapView: GMSMapView, didTap marker: GMSMarker) -> Bool {            // Update the single marker's distance if user location is available            if let userLocation = mapView.myLocation?.coordinate {                updateMarkerDistance(marker, from: userLocation)                currentlyOpenInfoWindow = marker            }            return false // Allow default behavior (info window)        }                // Called when info window is closed        func mapView(_ mapView: GMSMapView, didCloseInfoWindowOf marker: GMSMarker) {            currentlyOpenInfoWindow = nil        }                // Helper method to update all marker distances        func updateAllMarkerDistances(with userLocation: CLLocationCoordinate2D) {            // Update all event markers we're tracking            for marker in eventMarkers {                updateMarkerDistance(marker, from: userLocation)            }                        // If there's an info window currently open, force refresh it            if let openMarker = currentlyOpenInfoWindow, let mapView = openMarker.map {                // This reopens the info window to refresh its content                mapView.selectedMarker = nil                mapView.selectedMarker = openMarker            }        }                // Helper method to update a single marker's distance        private func updateMarkerDistance(_ marker: GMSMarker, from userLocation: CLLocationCoordinate2D) {            // Find if this is an event marker by checking userData            if marker.userData != nil, let title = marker.title {                // Find matching event                if let event = parent.eventManager.events.first(where: { $0.title == title }) {                    // Update distance in info window                    parent.eventManager.fetchDistance(                        from: userLocation,                        to: CLLocationCoordinate2D(latitude: event.latitude, longitude: event.longitude)                    ) { distance in                        DispatchQueue.main.async {                            var distanceInMiles: String = "Distance unavailable"                            if let distance = distance, let km = Double(distance.components(separatedBy: " ").first ?? "0") {                                let miles = km * 0.621371                                distanceInMiles = String(format: "%.1f miles away", miles)                            }                                                        // Format the date                            let dateFormatter = DateFormatter()                            dateFormatter.dateStyle = .medium                            dateFormatter.timeStyle = .short                            let formattedDate = dateFormatter.string(from: event.date)                                                        // Update the snippet with fresh distance                            marker.snippet = """                            Time: \(formattedDate)                            Address: \(event.location)                            \(distanceInMiles)                            """                                                        // Force refresh the info window if it's currently showing                            if self.currentlyOpenInfoWindow == marker, let mapView = marker.map {                                // This will force the info window to refresh                                mapView.selectedMarker = nil                                mapView.selectedMarker = marker                            }                        }                    }                }            }        }    }        // Helper function to add bar markers to the map        private func addBarMarkers(to mapView: GMSMapView, coordinator: Coordinator) {            let pinkColor = UIColor(red: 1.0, green: 0.2, blue: 0.6, alpha: 1.0) // Bright pink            for barLocation in barLocations {                let marker = GMSMarker(position: CLLocationCoordinate2D(latitude: barLocation.latitude, longitude: barLocation.longitude))                marker.title = barLocation.name                marker.snippet = barLocation.description                marker.icon = GMSMarker.markerImage(with: pinkColor)                marker.appearAnimation = .pop                marker.map = mapView                                // Bar markers are static, no need to track for distance updates            }            print("Added \(barLocations.count) bar markers to map")        }        private func addEventMarkers(to mapView: GMSMapView, coordinator: Coordinator) {        // Define your color scheme        let blueColor = UIColor(red: 0.0, green: 0.5, blue: 1.0, alpha: 1.0)        let friendColor = UIColor.purple  // Or any color you prefer for friend events                for event in eventManager.events {            let marker = GMSMarker(position: CLLocationCoordinate2D(                latitude: event.latitude,                longitude: event.longitude            ))                        // Set color based on friend status            marker.icon = GMSMarker.markerImage(with: event.isFriendEvent ? friendColor : blueColor)            marker.appearAnimation = .pop                        // Store full event data instead of just title            marker.userData = event                        coordinator.trackMarker(marker, isEvent: true)                        // Only fetch distance if user location is available            if let userLocation = mapView.myLocation?.coordinate {                eventManager.fetchDistance(                    from: userLocation,                    to: CLLocationCoordinate2D(                        latitude: event.latitude,                        longitude: event.longitude                    )                ) { distance in                    DispatchQueue.main.async {                        // Format distance                        var distanceInMiles = "Distance unavailable"                        if let distance = distance,                           let km = Double(distance.components(separatedBy: " ").first ?? "0") {                            let miles = km * 0.621371                            distanceInMiles = String(format: "%.1f miles away", miles)                        }                                                // Format date                        let dateFormatter = DateFormatter()                        dateFormatter.dateStyle = .medium                        dateFormatter.timeStyle = .short                        let formattedDate = dateFormatter.string(from: event.date)                                                // Set snippet with author information                        marker.snippet = """                        Host: \(event.authorUsername)                        Time: \(formattedDate)                        Address: \(event.location)                        \(distanceInMiles)                        """                                                // Add to map after updating snippet                        marker.map = mapView                    }                }            } else {                // Fallback snippet without distance                let dateFormatter = DateFormatter()                dateFormatter.dateStyle = .medium                dateFormatter.timeStyle = .short                let formattedDate = dateFormatter.string(from: event.date)                                marker.snippet = """                Host: \(event.authorUsername)                Time: \(formattedDate)                Address: \(event.location)                Distance unavailable                """                                marker.map = mapView            }                        print("Processing event marker: \(event.title) at \(event.latitude), \(event.longitude)")        }    }}