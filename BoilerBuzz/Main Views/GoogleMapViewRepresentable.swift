import SwiftUIimport GoogleMapsimport GooglePlaces// Model for event data from APIstruct EventData: Codable {    let _id: String    let title: String    let description: String    let location: String    let date: Double    let authorUsername: String}// Model for events with coordinatesstruct EventPin {    let id: String    let title: String    let description: String    let location: String    let date: Date    let authorUsername: String    let latitude: Double // Added latitude    let longitude: Double // Added longitude}// Response model for Geocoding APIstruct GeocodeResponse: Codable {    let results: [GeocodeResult]    let status: String // Added status field for better error handling}struct GeocodeResult: Codable {    let geometry: GeocodeGeometry}struct GeocodeGeometry: Codable {    let location: GeocodeLocation}struct GeocodeLocation: Codable {    let lat: Double    let lng: Double}struct BarLocation {    let name: String    let description: String    let latitude: Double    let longitude: Double}struct DistanceMatrixResponse: Codable {    struct Row: Codable {        struct Element: Codable {            struct Distance: Codable {                let text: String                let value: Int            }                        let distance: Distance            let status: String        }                let elements: [Element]    }        let rows: [Row]}class EventManager: ObservableObject {    @Published var events: [EventPin] = [] // Make published for UI updates    @Published var isLoading = true // Control loading state    var errorMessage: String?    private let baseURL = "http://localhost:3000/api/pin"    private let googleMapsAPIKey = "AIzaSyD9fysUB7FOQTQILo0TEdTOo59cL-4weVM"        func fetchDistance(from origin: CLLocationCoordinate2D, to destination: CLLocationCoordinate2D, completion: @escaping (String?) -> Void) {        let baseURL = "https://maps.googleapis.com/maps/api/distancematrix/json"        let originParam = "\(origin.latitude),\(origin.longitude)"        let destinationParam = "\(destination.latitude),\(destination.longitude)"        let urlString = "\(baseURL)?origins=\(originParam)&destinations=\(destinationParam)&key=\(googleMapsAPIKey)"                guard let url = URL(string: urlString) else {            print("Invalid Distance Matrix URL")            completion(nil)            return        }                URLSession.shared.dataTask(with: url) { data, response, error in            if let error = error {                print("Distance Matrix API error: \(error.localizedDescription)")                completion(nil)                return            }                        guard let data = data else {                print("No data received from Distance Matrix API")                completion(nil)                return            }                        do {                let response = try JSONDecoder().decode(DistanceMatrixResponse.self, from: data)                if let element = response.rows.first?.elements.first,                   element.status == "OK" {                    completion(element.distance.text)                } else {                    print("Failed to fetch distance")                    completion(nil)                }            } catch {                print("Error decoding Distance Matrix response: \(error)")                completion(nil)            }        }.resume()    }    func fetchUserEvents(completion: @escaping () -> Void) {        self.isLoading = true // Set loading state to true when starting                guard let userId = UserDefaults.standard.string(forKey: "userId") else {            print("User ID not found. Please log in again.")            errorMessage = "User ID not found. Please log in again."            self.isLoading = false // Important: Set to false even on error            completion()            return        }                print("Fetching RSVP events for user: \(userId)")        let urlString = "\(baseURL)/user-events/\(userId)"                guard let url = URL(string: urlString) else {            errorMessage = "Invalid URL"            self.isLoading = false // Important: Set to false even on error            completion()            return        }                URLSession.shared.dataTask(with: url) { [weak self] data, response, error in            guard let self = self else { return }                        if let error = error {                print("Network error: \(error.localizedDescription)")                self.errorMessage = "Network error: \(error.localizedDescription)"                DispatchQueue.main.async {                    self.isLoading = false // Important: Set to false even on error                    completion()                }                return            }                        guard let data = data else {                self.errorMessage = "No data received"                DispatchQueue.main.async {                    self.isLoading = false // Important: Set to false even on error                    completion()                }                return            }                        do {                let eventsData = try JSONDecoder().decode([EventData].self, from: data)                print("Received \(eventsData.count) events from API:")                                // Clear existing events                DispatchQueue.main.async {                    self.events.removeAll()                }                                // Track geocoding completion                let geocodingGroup = DispatchGroup()                                // Print event details and geocode locations                for event in eventsData {                    print("Event ID: \(event._id)")                    print("Title: \(event.title)")                    print("Description: \(event.description)")                    print("Location: \(event.location)")                    print("Date: \(Date(timeIntervalSince1970: event.date))")                    print("Author: \(event.authorUsername)")                    print("-------------------------------------------------")                                        // Enter dispatch group before starting geocoding                    geocodingGroup.enter()                                        // Geocode event location and add it as a pin                    self.geocodeAddress(event.location) { coordinate in                        defer {                            // Always leave the group, even if geocoding fails                            geocodingGroup.leave()                        }                                                if let coordinate = coordinate {                            // Create pin with coordinates                            let eventPin = EventPin(id: event._id,                                                  title: event.title,                                                  description: event.description,                                                  location: event.location,                                                  date: Date(timeIntervalSince1970: event.date/1000),                                                  authorUsername: event.authorUsername,                                                  latitude: coordinate.latitude,                                                  longitude: coordinate.longitude)                                                        // Add to events array on main thread                            DispatchQueue.main.async {                                self.events.append(eventPin)                                print("Added pin for event: \(event.title) at \(coordinate.latitude), \(coordinate.longitude)")                            }                        } else {                            print("Failed to geocode event location: \(event.location)")                        }                    }                }                                // When all geocoding is complete                geocodingGroup.notify(queue: .main) {                    print("All geocoding completed. Total events with coordinates: \(self.events.count)")                    self.isLoading = false // Set loading to false once all processing is done                    self.objectWillChange.send() // Notify observers of changes                    completion()                }                            } catch {                print("Error decoding events: \(error)")                self.errorMessage = "Error decoding events: \(error.localizedDescription)"                DispatchQueue.main.async {                    self.isLoading = false // Important: Set to false even on error                    completion()                }            }        }.resume()    }        func geocodeAddress(_ address: String, completion: @escaping (CLLocationCoordinate2D?) -> Void) {        // Append city and state to the address        let fullAddress = "\(address), West Lafayette, IN"        print("Geocoding address: \(fullAddress)")                // Encode the full address to be safe for a URL        let geocodeURLString = "https://maps.googleapis.com/maps/api/geocode/json?address=\(fullAddress.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")&key=\(googleMapsAPIKey)"        print("Geocode URL: \(geocodeURLString)")                guard let geocodeURL = URL(string: geocodeURLString) else {            print("Invalid geocode URL")            completion(nil)            return        }                URLSession.shared.dataTask(with: geocodeURL) { data, response, error in            // Print HTTP status for debugging            if let httpResponse = response as? HTTPURLResponse {                print("Geocoding HTTP status: \(httpResponse.statusCode)")            }                        if let error = error {                print("Geocoding error: \(error.localizedDescription)")                completion(nil)                return            }                        guard let data = data else {                print("No data received from geocoding API")                completion(nil)                return            }                        do {                let geocodeResponse = try JSONDecoder().decode(GeocodeResponse.self, from: data)                print("Geocoding status: \(geocodeResponse.status)")                print("Received \(geocodeResponse.results.count) geocoding results")                                if let firstResult = geocodeResponse.results.first {                    let latitude = firstResult.geometry.location.lat                    let longitude = firstResult.geometry.location.lng                    print("First result: \(latitude), \(longitude)")                    completion(CLLocationCoordinate2D(latitude: latitude, longitude: longitude))                } else {                    print("No results found for address: \(address)")                    completion(nil)                }            } catch {                print("Error decoding geocoding response: \(error)")                // Print raw response for debugging                if let jsonString = String(data: data, encoding: .utf8) {                    print("Raw geocoding response: \(jsonString)")                }                completion(nil)            }        }.resume()    }}struct GoogleMapViewRepresentable: UIViewRepresentable {    var location: CLLocationCoordinate2D?    @ObservedObject var eventManager: EventManager        // Hard-coded bar locations    private let barLocations: [BarLocation] = [        BarLocation(name: "Harry's Chocolate Shop", description: "Popular campus bar", latitude: 40.42378, longitude: -86.90908),        BarLocation(name: "Brothers Bar & Grill", description: "Sports bar with food", latitude: 40.42415, longitude: -86.90838),        BarLocation(name: "The Tap", description: "Craft beer bar", latitude: 40.42305, longitude: -86.90683),        BarLocation(name: "Where Else", description: "Youthful bar", latitude: 40.42407, longitude: -86.90854),        BarLocation(name: "9 Irish Brothers", description: "Cozy vibe and great Guinness", latitude: 40.42306, longitude: -86.90321),        BarLocation(name: "Neon Cactus", description: "Giant club on campus", latitude: 40.42329, longitude: -86.90065)    ]        func makeUIView(context: Context) -> GMSMapView {        let options = GMSMapViewOptions()        // Center on West Lafayette with appropriate zoom        options.camera = GMSCameraPosition.camera(withLatitude: 40.4240,                                                  longitude: -86.9080, zoom: 15)        let mapView = GMSMapView(options: options)        mapView.isMyLocationEnabled = true        mapView.settings.myLocationButton = true                // Initially add bar markers        addBarMarkers(to: mapView)                return mapView    }        func updateUIView(_ uiView: GMSMapView, context: Context) {        print("updateUIView called, isLoading: \(eventManager.isLoading), events count: \(eventManager.events.count)")                if !eventManager.isLoading {            uiView.clear() // Clear existing markers                        // Re-add all markers            addBarMarkers(to: uiView)            addEventMarkers(to: uiView)                        if let location = location {                // Animate camera to user location                let camera = GMSCameraPosition.camera(withLatitude: location.latitude,                                                      longitude: location.longitude,                                                      zoom: 15)                uiView.animate(to: camera)            } else if let firstEvent = eventManager.events.first {                // If no specific location but we have events, center on first event                let camera = GMSCameraPosition.camera(withLatitude: firstEvent.latitude,                                                      longitude: firstEvent.longitude,                                                      zoom: 15)                uiView.animate(to: camera)            }        }    }        // Helper function to add bar markers to the map    private func addBarMarkers(to mapView: GMSMapView) {        let pinkColor = UIColor(red: 1.0, green: 0.4, blue: 0.7, alpha: 1.0) // Bright pink        for barLocation in barLocations {            let marker = GMSMarker(position: CLLocationCoordinate2D(latitude: barLocation.latitude,                                                                    longitude: barLocation.longitude))            marker.title = barLocation.name            marker.snippet = barLocation.description            marker.icon = GMSMarker.markerImage(with: pinkColor)            marker.appearAnimation = .pop            marker.map = mapView        }        print("Added \(barLocations.count) bar markers to map")    }        private func addEventMarkers(to mapView: GMSMapView) {        let blueColor = UIColor(red: 0.0, green: 0.5, blue: 1.0, alpha: 1.0)                for event in eventManager.events {            let marker = GMSMarker(position: CLLocationCoordinate2D(latitude: event.latitude, longitude: event.longitude))            marker.title = event.title            marker.icon = GMSMarker.markerImage(with: blueColor)            marker.appearAnimation = .pop                        // Create a unique identifier for this marker to track updates            let markerId = UUID().uuidString            marker.userData = markerId                        // Only fetch distance if user location is available            if let userLocation = mapView.myLocation?.coordinate {                // Don't add marker to map yet                eventManager.fetchDistance(from: userLocation, to: CLLocationCoordinate2D(latitude: event.latitude, longitude: event.longitude)) { distance in                    DispatchQueue.main.async {                        // Check if this is still the latest update for this marker                        if marker.userData as? String == markerId {                            var distanceInMiles: String = "Distance unavailable"                            if let distance = distance, let km = Double(distance.components(separatedBy: " ").first ?? "0") {                                let miles = km * 0.621371                                distanceInMiles = String(format: "%.1f miles away", miles)                            }                                                        // Format the date                            let dateFormatter = DateFormatter()                            dateFormatter.dateStyle = .medium                            dateFormatter.timeStyle = .short                            let formattedDate = dateFormatter.string(from: event.date)                                                        // Set the snippet with the fresh distance data                            marker.snippet = """                            Time: \(formattedDate)                            Address: \(event.location)                            \(distanceInMiles)                            """                                                        // Only add to map AFTER distance has been calculated and snippet updated                            marker.map = mapView                        }                    }                }            } else {                // Fallback if user location is not available                let dateFormatter = DateFormatter()                dateFormatter.dateStyle = .medium                dateFormatter.timeStyle = .short                let formattedDate = dateFormatter.string(from: event.date)                                marker.snippet = """                Time: \(formattedDate)                Address: \(event.location)                Distance unavailable                """                marker.map = mapView            }                        print("Processing event marker: \(event.title) at \(event.latitude), \(event.longitude)")        }    }}